<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <title>Pac-Man V10 (Perfect Version)</title>    <style>        body {            background-color: #000;            color: white;            display: flex;            flex-direction: column;            align-items: center;            justify-content: center;            min-height: 100vh;            margin: 0;            font-family: 'Courier New', Courier, monospace;            overflow: hidden;        }        h1 { margin-bottom: 5px; color: #FFD700; text-shadow: 2px 2px #d35400; font-size: 28px;}        #gameCanvas {            border: 4px solid #3333FF;            background-color: black;            box-shadow: 0 0 25px rgba(51, 51, 255, 0.7);            display: block;        }        #ui-layer { margin-top: 10px; text-align: center; width: 456px; }        .info { font-size: 20px; display: flex; justify-content: space-between; margin-bottom: 5px; }        .controls { font-size: 14px; color: #aaa; margin-top: 8px; line-height: 1.4; }        #status-msg { color: #ffff00; font-weight: bold; height: 20px; }        .highlight { color: #00ff00; }        .credit { color: #00ffff; margin-top: 5px; font-size: 12px; }    </style></head><body>    <h1>PAC-MAN V10</h1>    <canvas id="gameCanvas" width="456" height="528"></canvas>        <div id="ui-layer">        <div class="info">            <span>SCORE: <span id="score">0</span> | LEVEL: <span id="level">1</span>/2</span>            <span id="status-msg">PRESS SPACE TO START</span>        </div>        <div class="controls">            ???????? MOVE | ?? POWER PELLET: EAT GHOSTS<br>            <span class="highlight">TIP: Win 2 levels for the Ending!</span><br>            If Game Over: Press 'R' to Revive | 'Space' to Reset        </div>    </div><script>    const canvas = document.getElementById("gameCanvas");    const ctx = canvas.getContext("2d");    const scoreEl = document.getElementById("score");    const levelEl = document.getElementById("level");    const statusEl = document.getElementById("status-msg");    // --- Game Parameters ---    const tileSize = 24;    const pacmanSpeed = 3;    const ghostSpeed = 2;     // Game State    let score = 0;    let gameActive = false;    let animationId = null;    let powerModeTime = 0;    const powerDuration = 500;    let isWin = false;    let currentLevelIndex = 0;    let isTransitioning = false;    // --- Map Definitions ---    // 1=Wall, 0=Dot, 2=Empty, 3=PowerPellet, 9=GhostDoor, 4=Tunnel        // Level 1: Classic    const mapL1 = [        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],        [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],        [1,3,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,3,1],        [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],        [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],        [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],        [1,1,1,1,0,1,1,1,2,1,2,1,1,1,0,1,1,1,1],        [2,2,2,1,0,1,2,2,2,2,2,2,2,1,0,1,2,2,2],        [1,1,1,1,0,1,2,1,1,9,1,1,2,1,0,1,1,1,1],        [4,4,4,4,0,2,2,1,2,2,2,1,2,2,0,4,4,4,4],        [1,1,1,1,0,1,2,1,1,1,1,1,2,1,0,1,1,1,1],        [2,2,2,1,0,1,2,2,2,2,2,2,2,1,0,1,2,2,2],        [1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1],        [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],        [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],        [1,3,0,1,0,0,0,0,0,2,0,0,0,0,0,1,0,3,1],        [1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1],        [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],        [1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1],        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]    ];    // Level 2: Bonus    const mapL2 = [        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],        [1,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1],        [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],        [1,0,1,2,2,1,0,0,0,0,0,0,0,1,2,2,1,0,1],        [1,0,1,2,2,1,0,1,1,1,1,1,0,1,2,2,1,0,1],        [1,0,1,1,1,1,0,1,2,2,2,1,0,1,1,1,1,0,1],        [1,0,0,0,0,0,0,1,2,2,2,1,0,0,0,0,0,0,1],        [1,1,1,1,0,1,1,1,2,2,2,1,1,1,0,1,1,1,1],        [2,2,2,1,0,1,2,2,2,2,2,2,2,1,0,1,2,2,2],        [1,1,1,1,0,1,2,1,1,9,1,1,2,1,0,1,1,1,1],        [4,4,4,4,0,2,2,1,2,2,2,1,2,2,0,4,4,4,4],        [1,1,1,1,0,1,2,1,1,1,1,1,2,1,0,1,1,1,1],        [2,2,2,1,0,1,2,2,2,2,2,2,2,1,0,1,2,2,2],        [1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1],        [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],        [1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1],        [1,0,1,2,2,1,0,0,0,2,0,0,0,1,2,2,1,0,1],        [1,0,1,2,2,1,0,1,1,1,1,1,0,1,2,2,1,0,1],        [1,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1],        [1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1],        [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]    ];    const levels = [mapL1, mapL2];    const rows = mapL1.length;    const cols = mapL1[0].length;    let map = [];    let pacman = {};    let ghosts = [];    function resetPositions() {        // Pacman Start Position        pacman = {             x: tileSize * 9, y: tileSize * 16,             vx: 0, vy: 0, nextVx: 0, nextVy: 0,             angle: 0, radius: tileSize/2 - 2        };        // Ghost Start Positions        ghosts = [            { x: 9 * tileSize, y: 8 * tileSize, color: "red", baseColor: "red", vx: 0, vy: 0, type: 'chase' },            { x: 9 * tileSize, y: 10 * tileSize, color: "pink", baseColor: "pink", vx: 0, vy: 0, type: 'ambush' },            { x: 8 * tileSize, y: 10 * tileSize, color: "cyan", baseColor: "cyan", vx: 0, vy: 0, type: 'random' },            { x: 10 * tileSize, y: 10 * tileSize, color: "orange", baseColor: "orange", vx: 0, vy: 0, type: 'random' }        ];        powerModeTime = 0;    }    function initGame() {        currentLevelIndex = 0;        score = 0;        isTransitioning = false;        scoreEl.innerText = score;        levelEl.innerText = currentLevelIndex + 1;        startLevel();    }    function startLevel() {        map = JSON.parse(JSON.stringify(levels[currentLevelIndex]));        isWin = false;        isTransitioning = false;        resetPositions();                statusEl.innerText = `LEVEL ${currentLevelIndex + 1} START!`;         statusEl.style.color = "#ffff00";        levelEl.innerText = currentLevelIndex + 1;                if (animationId) cancelAnimationFrame(animationId);        gameActive = true;        gameLoop();    }    function reviveGame() {        if (isWin) return;        resetPositions();        statusEl.innerText = "REVIVED! KEEP GOING!";         statusEl.style.color = "#00ff00";        if (animationId) cancelAnimationFrame(animationId);        gameActive = true;        gameLoop();    }    document.addEventListener("keydown", (e) => {        if(["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","r","R"].indexOf(e.key) > -1) e.preventDefault();                if (!gameActive) {            if (!isTransitioning) {                if (e.code === "Space") initGame();                else if ((e.key === "r" || e.key === "R") && !isWin) reviveGame();            }            return;        }        switch(e.key) {            case "ArrowUp":    pacman.nextVx = 0; pacman.nextVy = -pacmanSpeed; pacman.angle = 1.5 * Math.PI; break;            case "ArrowDown":  pacman.nextVx = 0; pacman.nextVy = pacmanSpeed; pacman.angle = 0.5 * Math.PI; break;            case "ArrowLeft":  pacman.nextVx = -pacmanSpeed; pacman.nextVy = 0; pacman.angle = Math.PI; break;            case "ArrowRight": pacman.nextVx = pacmanSpeed; pacman.nextVy = 0; pacman.angle = 0; break;        }    });    function isWall(x, y, isGhost) {        const c = Math.floor(x / tileSize); const r = Math.floor(y / tileSize);        if (r < 0 || r >= rows || c < 0 || c >= cols) return false;        const cell = map[r][c];        if (cell === 1) return true;        if (cell === 9) return !isGhost;        return false;    }    function checkCollision(obj, nextVx, nextVy, isGhost) {        const padding = 1;        const nextX = obj.x + nextVx; const nextY = obj.y + nextVy;        return (            isWall(nextX + padding, nextY + padding, isGhost) ||            isWall(nextX + tileSize - padding, nextY + padding, isGhost) ||            isWall(nextX + padding, nextY + tileSize - padding, isGhost) ||            isWall(nextX + tileSize - padding, nextY + tileSize - padding, isGhost)        );    }    function handleTunnel(obj) {        if (obj.x > canvas.width) obj.x = -tileSize;        else if (obj.x < -tileSize) obj.x = canvas.width;    }    function movePacman() {        handleTunnel(pacman);        if (pacman.nextVx !== 0 || pacman.nextVy !== 0) {            if (!checkCollision(pacman, pacman.nextVx, pacman.nextVy, false)) {                if (pacman.nextVx !== 0) pacman.y = Math.round(pacman.y / tileSize) * tileSize;                if (pacman.nextVy !== 0) pacman.x = Math.round(pacman.x / tileSize) * tileSize;                pacman.vx = pacman.nextVx; pacman.vy = pacman.nextVy;                pacman.nextVx = 0; pacman.nextVy = 0;            }        }        if (!checkCollision(pacman, pacman.vx, pacman.vy, false)) {            pacman.x += pacman.vx; pacman.y += pacman.vy;        } else {            pacman.vx = 0; pacman.vy = 0;        }                const cx = Math.floor((pacman.x + tileSize/2) / tileSize);        const cy = Math.floor((pacman.y + tileSize/2) / tileSize);        if (cy >= 0 && cy < rows && cx >= 0 && cx < cols) {            if (map[cy][cx] === 0) {                 map[cy][cx] = 2; score += 10; scoreEl.innerText = score; checkWin();             } else if (map[cy][cx] === 3) {                 map[cy][cx] = 2; score += 50; scoreEl.innerText = score; activatePowerMode(); checkWin();             }        }    }    function activatePowerMode() {        powerModeTime = powerDuration;        statusEl.innerText = "POWER PELLET! EAT GHOSTS!"; statusEl.style.color = "#00ff00";        ghosts.forEach(g => g.color = "blue");    }    function moveGhosts() {        ghosts.forEach(g => {            handleTunnel(g);            if (g.x % tileSize === 0 && g.y % tileSize === 0) {                let moves = [];                const options = [{vx:0, vy:-ghostSpeed}, {vx:0, vy:ghostSpeed}, {vx:-ghostSpeed, vy:0}, {vx:ghostSpeed, vy:0}];                options.forEach(opt => {                    if (!checkCollision(g, opt.vx, opt.vy, true)) {                        if (g.vx === 0 && g.vy === 0) moves.push(opt);                        else if (opt.vx !== -g.vx || opt.vy !== -g.vy) moves.push(opt);                    }                });                if (moves.length === 0) moves.push({vx: -g.vx, vy: -g.vy});                                if (moves.length > 0) {                    let best = moves[0];                    if (powerModeTime > 0) best = moves[Math.floor(Math.random() * moves.length)];                    else if (g.type === 'chase' || g.type === 'ambush') {                        let minDst = Infinity;                        moves.forEach(m => {                            const dx = (g.x + m.vx) - pacman.x; const dy = (g.y + m.vy) - pacman.y;                            const dst = dx*dx + dy*dy;                            const noise = (g.type === 'ambush') ? Math.random() * 20000 : 0;                            if (dst + noise < minDst) { minDst = dst + noise; best = m; }                        });                    } else best = moves[Math.floor(Math.random() * moves.length)];                    g.vx = best.vx; g.vy = best.vy;                }            }            g.x += g.vx; g.y += g.vy;            const dist = Math.hypot(pacman.x - g.x, pacman.y - g.y);            if (dist < tileSize - 5) {                if (powerModeTime > 0) {                    g.x = 9 * tileSize; g.y = 10 * tileSize; g.color = g.baseColor; score += 200;                    statusEl.innerText = "GHOST EATEN +200!";                } else gameOver(false);            }        });    }    function checkWin() {        let hasDots = false;        for(let r=0; r<rows; r++) for(let c=0; c<cols; c++) if(map[r][c]===0 || map[r][c]===3) hasDots = true;                if (!hasDots && !isTransitioning) {            if (currentLevelIndex < levels.length - 1) {                isTransitioning = true;                gameActive = false;                ctx.fillStyle = "rgba(0,0,0,0.7)";                ctx.fillRect(0,0,canvas.width, canvas.height);                ctx.fillStyle = "#00ff00";                ctx.font = "30px Courier New";                ctx.textAlign = "center";                ctx.fillText("LEVEL COMPLETE!", canvas.width/2, canvas.height/2 - 20);                ctx.font = "20px Courier New";                ctx.fillStyle = "white";                ctx.fillText("Next Level Loading...", canvas.width/2, canvas.height/2 + 20);                statusEl.innerText = "LEVEL COMPLETE! LOADING NEXT...";                setTimeout(() => {                    currentLevelIndex++;                    startLevel();                }, 2000);            } else {                gameOver(true);            }        }    }    function gameOver(win) {        gameActive = false; isWin = win;        if (win) {            statusEl.innerText = "CONGRATULATIONS!";            statusEl.style.color = "#00ff00";        } else {            statusEl.innerText = "GAME OVER! Press 'R' to Revive";            statusEl.style.color = "#ff3333";        }        draw();    }    // --- New Pixel Art: Girl Blowing Kiss ---    function drawFinalVictoryScreen(ctx) {        const scale = 14; // Adjusted scale        // H=Hair, S=Skin, E=Eye(closed/wink), O=Eye(open), R=Lips/Heart, C=Dress        const pixelMap = [            "...........................",            ".....HHHHHHHHH.............",            "...HHHHHHHHHHHHH...........",            "..HHHHHHHHHHHHHHH..........",            ".HHHHSSSSHHHHHSSHH.........",            ".HHSSSSSSSSSSSSSSHH........",            ".HHOSSSSSSSSSSEESHH........", // O=Open eye, EE=Wink eye            ".HHSSSSSSSSSSSSSSHH........",            "..HSSSSSSRRSSSSSSH.........", // RR=Puckered lips            "..HSSSSSSRRSSSSSSH.........",            "...HSSSSSSSSSSSSH..........",            "...HSSSSSSSSSSSSSH.....RR..", // Flying Heart            "....HSSSSSSSSSSSH.....RRRR.",            "....CCSSSSSSSSSCC.....RRRR.",            "...CCCCSSSSSSCCCC......RR..",            "..CCCCCCSSSSCCCCCC.........",            "..........................."        ];        const colors = {            'H': '#8B4513', // SaddleBrown Hair            'S': '#FFE0BD', // Light Skin Tone            'E': '#000000', // Closed Eye            'O': '#000000', // Open Eye            'R': '#FF0000', // Red Lips/Heart            'C': '#FF69B4'  // Pink dress        };        const startX = (canvas.width - pixelMap[0].length * scale) / 2;        const startY = 100;        for(let r=0; r<pixelMap.length; r++) {            for(let c=0; c<pixelMap[r].length; c++) {                const char = pixelMap[r][c];                if (colors[char]) {                    ctx.fillStyle = colors[char];                    ctx.fillRect(startX + c*scale, startY + r*scale, scale, scale);                }            }        }        ctx.fillStyle = "#FFD700";        ctx.font = "40px Courier New";        ctx.textAlign = "center";        ctx.fillText("CONGRATULATIONS!", canvas.width/2, 80);                ctx.font = "20px Courier New";        ctx.fillStyle = "white";        ctx.fillText("You Won The Game!", canvas.width/2, 400);        // --- CREDIT ---        ctx.font = "16px Courier New";        ctx.fillStyle = "#00ffff";        ctx.fillText("Designed by Gemini and BusinessFocus", canvas.width/2, 440);        ctx.font = "16px Courier New";        ctx.fillStyle = "#aaa";        ctx.fillText("Press 'Space' to Play Again", canvas.width/2, 480);    }    function draw() {        if (!gameActive && isTransitioning) return;        ctx.fillStyle = "black";        ctx.fillRect(0, 0, canvas.width, canvas.height);        // Map        for(let r=0; r<rows; r++){            for(let c=0; c<cols; c++){                const x = c*tileSize; const y = r*tileSize;                const cell = map[r][c];                if(cell === 1) {                    ctx.fillStyle = "#3333FF"; ctx.fillRect(x, y, tileSize, tileSize);                    ctx.fillStyle = "black"; ctx.fillRect(x+2, y+2, tileSize-4, tileSize-4);                } else if(cell === 9) {                    ctx.fillStyle = "#FF88CC"; ctx.fillRect(x, y+tileSize/2-2, tileSize, 4);                } else if(cell === 0) {                    ctx.fillStyle = "#FFB897"; ctx.beginPath(); ctx.arc(x+tileSize/2, y+tileSize/2, 3, 0, Math.PI*2); ctx.fill();                } else if(cell === 3) {                    ctx.fillStyle = (Math.floor(Date.now()/200)%2===0) ? "#FFF" : "#FFB897";                    ctx.beginPath(); ctx.arc(x+tileSize/2, y+tileSize/2, 8, 0, Math.PI*2); ctx.fill();                }            }        }        const px = pacman.x + tileSize/2; const py = pacman.y + tileSize/2;        ctx.fillStyle = "yellow"; ctx.beginPath();        const mouth = (Date.now() % 200 < 100) ? 0.2 : 0.05;        const start = pacman.angle + mouth * Math.PI; const end = pacman.angle + (2 - mouth) * Math.PI;        ctx.arc(px, py, pacman.radius, start, end); ctx.lineTo(px, py); ctx.fill();        ghosts.forEach(g => {            ctx.fillStyle = (powerModeTime > 0) ? (powerModeTime < 120 && Math.floor(Date.now()/100)%2===0 ? "white" : "blue") : g.color;            ctx.beginPath();            const gx = g.x + tileSize/2; const gy = g.y + tileSize/2;            ctx.arc(gx, gy, tileSize/2 - 2, Math.PI, 0);            ctx.lineTo(gx + tileSize/2 - 2, gy + tileSize/2); ctx.lineTo(gx - tileSize/2 + 2, gy + tileSize/2); ctx.fill();            if (powerModeTime <= 0) {                ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(gx - 4, gy - 4, 4, 0, Math.PI*2); ctx.arc(gx + 4, gy - 4, 4, 0, Math.PI*2); ctx.fill();                ctx.fillStyle = "black"; ctx.beginPath(); ctx.arc(gx - 4, gy - 4, 2, 0, Math.PI*2); ctx.arc(gx + 4, gy - 4, 2, 0, Math.PI*2); ctx.fill();            }        });        if (!gameActive && !isTransitioning) {            if (isWin && currentLevelIndex === levels.length - 1) {                ctx.fillStyle = "rgba(0,0,0,0.95)";                ctx.fillRect(0,0,canvas.width, canvas.height);                drawFinalVictoryScreen(ctx);            } else {                ctx.fillStyle = "rgba(0,0,0,0.85)";                ctx.fillRect(0,0,canvas.width, canvas.height);                ctx.fillStyle = "white"; ctx.textAlign = "center";                if (score === 0 && map.length === 0) {                     ctx.font = "24px Courier New"; ctx.fillText("PRESS SPACE TO START", canvas.width/2, canvas.height/2);                } else {                    ctx.font = "40px Courier New"; ctx.fillStyle = "#ff3333";                    ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2 - 40);                    ctx.fillStyle = "white"; ctx.font = "24px Courier New";                    ctx.fillText("SCORE: " + score, canvas.width/2, canvas.height/2 + 10);                    ctx.fillStyle = "#ffff00"; ctx.fillText("Press 'R' to Revive", canvas.width/2, canvas.height/2 + 60);                    ctx.fillStyle = "#aaa"; ctx.font = "16px Courier New"; ctx.fillText("(Press 'Space' to Reset)", canvas.width/2, canvas.height/2 + 100);                }            }        }    }    function gameLoop() {        if (!gameActive) return;        if (powerModeTime > 0) {            powerModeTime--;            if (powerModeTime <= 0) { statusEl.innerText = "GAME ON!"; statusEl.style.color = "#ffff00"; }        }        movePacman(); moveGhosts(); draw();        animationId = requestAnimationFrame(gameLoop);    }    draw();</script></body></html>